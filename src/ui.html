
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Live Blog (Simulated)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: #0b0c0c; color: #fff; }
      header { position: sticky; top: 0; backdrop-filter: blur(6px); background: rgba(0,0,0,0.5); padding: 12px 16px; border-bottom: 1px solid #333; }
      .live { display: inline-flex; align-items: center; gap: 8px; font-weight: 700; }
      .dot { width: 10px; height: 10px; border-radius: 50%; background: #ff4d4f; box-shadow: 0 0 0 0 rgba(255,77,79, 0.7); animation: pulse 1.4s infinite; }
      @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(255,77,79,.7);} 70%{box-shadow:0 0 0 8px rgba(255,77,79,0);} 100%{box-shadow:0 0 0 0 rgba(255,77,79,0);} }
      main { max-width: 860px; margin: 24px auto; padding: 0 16px 80px; }
      .card { background: #111; border: 1px solid #333; border-radius: 16px; padding: 16px 18px; margin: 14px 0; box-shadow: 0 6px 20px rgba(0,0,0,.2); }
      .meta { font-size: 12px; color: #aaa; margin-bottom: 6px; }
      h3 { margin: 8px 0 8px; font-size: 18px; }
      ul { margin: 8px 0 0 18px; }
      .small { font-size: 12px; color: #bbb; }
      .empty { opacity: .7; text-align: center; padding: 40px 0; }
    </style>
  </head>
  <body>
    <header>
      <div class="live"><span class="dot"></span> Live blog (simulated)</div>
    </header>
    <main>
      <div style="margin: 18px 0 24px 0;">
        <input type="file" id="audioFile" accept="audio/*" />
        <button id="playBtn" disabled>Play & Stream</button>
      </div>
      <audio id="audio" controls style="width:100%; display:none;"></audio>
      <div id="list" class="empty">Waiting for chunks…</div>
    </main>
    <script>
      const list = document.getElementById('list');
      const fmt = s => new Date(s*1000).toISOString().substring(14,19);
      const es = new EventSource('/stream');
      const add = c => {
        if (list.classList.contains('empty')) list.classList.remove('empty'), list.innerHTML='';
        const el = document.createElement('article');
        el.className = 'card';
        el.innerHTML = `
          <div class="meta">${fmt(c.time_start)}–${fmt(c.time_end)} • conf ${(c.confidence*100).toFixed(0)}%</div>
          <h3>${escapeHtml(c.headline)}</h3>
          <ul>${c.bullets.map(b=>`<li>${escapeHtml(b)}</li>`).join('')}</ul>
          ${c.quotes?.length? `<div class="small"><strong>Quotes:</strong> ${c.quotes.map(q=>`“${escapeHtml(q)}”`).join(' · ')}</div>`:''}
        `;
        list.prepend(el);
      };
      es.addEventListener('chunk', ev => add(JSON.parse(ev.data)));
      es.addEventListener('eof', () => {
        const done = document.createElement('div');
        done.className = 'small';
        done.textContent = 'End of file';
        list.prepend(done);
      });
      function escapeHtml(s){return s.replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[c]))}

      // --- Audio file selection and streaming (send raw decoded PCM s16le) ---
      const audioFile = document.getElementById('audioFile');
      const playBtn = document.getElementById('playBtn');
      const audio = document.getElementById('audio');
      let selectedFile = null;
      let decodedBuffer = null;
      let ws = null;
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      // helper: convert Float32Array (interleaved) to Int16 PCM (s16le)
      function floatTo16BitPCM(float32Array) {
        const l = float32Array.length;
        const buffer = new ArrayBuffer(l * 2);
        const view = new DataView(buffer);
        let offset = 0;
        for (let i = 0; i < l; i++, offset += 2) {
          let s = Math.max(-1, Math.min(1, float32Array[i]));
          view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);
        }
        return buffer;
      }

      audioFile.addEventListener('change', async e => {
        const file = e.target.files[0];
        if (file) {
          selectedFile = file;
          // decode into AudioBuffer for raw PCM extraction
          const ab = await file.arrayBuffer();
          decodedBuffer = await audioCtx.decodeAudioData(ab.slice(0));
          const url = URL.createObjectURL(file);
          audio.src = url;
          audio.style.display = '';
          playBtn.disabled = false;
        } else {
          playBtn.disabled = true;
          audio.style.display = 'none';
          selectedFile = null;
          decodedBuffer = null;
        }
      });

      playBtn.addEventListener('click', async () => {
        if (!decodedBuffer || !selectedFile) return;
        playBtn.disabled = true;
        const wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
        ws = new WebSocket(`${wsProtocol}://${location.host}/audio-stream`);
        ws.binaryType = 'arraybuffer';

        // chunking params
        const chunkSeconds = 0.25; // 250ms chunks
        const sr = decodedBuffer.sampleRate;
        const channels = decodedBuffer.numberOfChannels;
        const chunkSamples = Math.floor(chunkSeconds * sr);

        let lastSentSample = 0;
        let intervalId = null;

        ws.onopen = () => {
          // handshake with format info
          ws.send(JSON.stringify({ kind: 'handshake', format: 's16le', sampleRate: sr, channels, name: selectedFile.name }));
          lastSentSample = 0;
          audio.currentTime = 0;
          audio.play();

          // send loop (interval ensures ordered sends)
          intervalId = setInterval(() => {
            if (!ws || ws.readyState !== 1 || audio.paused) return;
            const currentSample = Math.floor(audio.currentTime * sr);
            if (currentSample <= lastSentSample) return;
            const end = Math.min(currentSample, decodedBuffer.length);
            // build interleaved Float32
            const frames = end - lastSentSample;
            let interleaved = null;
            if (channels === 1) {
              interleaved = decodedBuffer.getChannelData(0).subarray(lastSentSample, end);
            } else {
              interleaved = new Float32Array(frames * channels);
              let idx = 0;
              for (let i = lastSentSample; i < end; i++) {
                for (let ch = 0; ch < channels; ch++) {
                  interleaved[idx++] = decodedBuffer.getChannelData(ch)[i];
                }
              }
            }
            // convert and send
            const pcm16 = floatTo16BitPCM(interleaved);
            try { ws.send(pcm16); } catch (e) { console.error('ws send failed', e); }
            lastSentSample = end;
          }, Math.max(50, chunkSeconds * 1000));
        };

        ws.onclose = () => {
          playBtn.disabled = false;
          if (intervalId) clearInterval(intervalId);
        };

        audio.addEventListener('pause', () => {
          if (intervalId) clearInterval(intervalId);
        });

        audio.addEventListener('ended', () => {
          // send remaining samples
          if (lastSentSample < decodedBuffer.length && ws && ws.readyState === 1) {
            const end = decodedBuffer.length;
            const frames = end - lastSentSample;
            let interleaved = null;
            if (channels === 1) {
              interleaved = decodedBuffer.getChannelData(0).subarray(lastSentSample, end);
            } else {
              interleaved = new Float32Array(frames * channels);
              let idx = 0;
              for (let i = lastSentSample; i < end; i++) {
                for (let ch = 0; ch < channels; ch++) {
                  interleaved[idx++] = decodedBuffer.getChannelData(ch)[i];
                }
              }
            }
            const pcm16 = floatTo16BitPCM(interleaved);
            try { ws.send(pcm16); } catch (e) { console.error('ws send failed', e); }
          }
          if (ws && ws.readyState === 1) ws.close();
          playBtn.disabled = false;
          if (intervalId) clearInterval(intervalId);
        });
      });
    </script>
  </body>
</html>